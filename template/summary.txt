---------------------------------------
---------------------------------------
I Основные вопросы, которые решает конструкция template
---------------------------------------
---------------------------------------

---------------------------------------
1. Универсальное (generic) программирование
---------------------------------------
Шаблоны позволяют писать алгоритмы и структуры данных независимо от конкретного типа, избегая дублирования кода и сохраняя типовую безопасность.

---------------------------------------
2. Компиляция на этапе компиляции (compile-time computation)
---------------------------------------
С помощью шаблонного метапрограммирования и if constexpr можно выполнять вычисления до запуска программы, получая оптимальный низкоуровневый код.

---------------------------------------
3. Полиморфизм во время компиляции (static polymorphism)
---------------------------------------
Через CRTP и шаблонные параметры достигается замена виртуальных вызовов на инлайнинг без накладных расходов в рантайме.

---------------------------------------
4. Параметры-шаблоны не только типов, но и значений
---------------------------------------
Можно передавать в шаблоны целочисленные константы и даже другие шаблоны для гибкой настройки алгоритмов.

---------------------------------------
5. Ограничение параметров через Concepts (C++20)
---------------------------------------
Позволяет точно описать требования к типам, улучшить читаемость и качество диагностических сообщений.


---------------------------------------
---------------------------------------
II Проблемы, которые встречаются при использовании шаблонов
---------------------------------------
---------------------------------------

---------------------------------------
1. Чрезмерно подробные и запутанные сообщения об ошибках
---------------------------------------
Компилятор расписывает все параметры шаблонов и их инстанцирование, из-за чего одно простое опечатка может превратиться в тысячу строк трейсбека.

---------------------------------------
2. Увеличение времени компиляции и расход памяти
---------------------------------------
Каждый набор аргументов шаблона генерирует новый код, что замедляет сборку и нагружает компилятор.

---------------------------------------
3. Рост размера объектов (code bloat)
---------------------------------------
Избыточные инстанцирования шаблонов приводят к дублированию машинного кода, особенно при наивном подходе.

---------------------------------------
4. Сложности в специализации и разрешении перегрузок
---------------------------------------
Неочевидные правила SFINAE и lookup-зависимые имена могут привести к тонким ошибкам и неоднозначностям.

---------------------------------------
5. Неоднозначности с ADL и using std::swap
---------------------------------------
Неправильное подключение swap через ADL может нарушить ожидаемое поведение или сломать std::swap для других типов.


---------------------------------------
---------------------------------------
III Базовые конструкции шаблонов
---------------------------------------
---------------------------------------

---------------------------------------
1. Функция-шаблон (Function Template)
---------------------------------------
Функция-шаблон генерирует версии под каждый использованный тип: main_1.cpp.

---------------------------------------
2. Класс-шаблон (Class Template)
---------------------------------------
Класс-шаблон создаёт семейство типов Pair<T1,T2>: main_2.cpp.

---------------------------------------
3. Alias-шаблон (Alias Template)
---------------------------------------
Alias-шаблон создаёт семейство псевдонимов типов: main_3.cpp.

---------------------------------------
4. Переменная-шаблон (Variable Template)
---------------------------------------
Переменная-шаблон генерирует pi<T> для любых числовых типов: main_4.cpp.

---------------------------------------
5. Шаблон с не-типовым параметром и пакетом параметров
---------------------------------------
Fold-expression сворачивает пакет аргументов во время компиляции: main_5.cpp.


---------------------------------------
---------------------------------------
IV Сложные ситуации
---------------------------------------
---------------------------------------

---------------------------------------
1. Универсальный swap с ADL и noexcept
---------------------------------------
ADL (using std::swap;) гарантирует вызов специализированного swap, а noexcept отражает корректность исключений: main_6.cpp.

---------------------------------------
2. Факториал на этапе компиляции
---------------------------------------
if constexpr упрощает метапрограммирование без специализаций: main_7.cpp.

---------------------------------------
3. Ограничение через Concepts (C++20)
---------------------------------------
Concepts улучшают диагностику и читаемость шаблонов: main_8.cpp.

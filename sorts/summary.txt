---------------------------------------
QuickSort (быстрая сортировка)
---------------------------------------
Задачи:
• Общая нереляционная сортировка «на все случаи» (векторы, массивы).
• Интерактивные системы, где важна средняя скорость.
• Реализация std::sort в STL.
Почему: в среднем O(n log n), прост в реализации и отлично кэшится.

---------------------------------------
Merge Sort (сортировка слиянием)
---------------------------------------
Задачи:
• Внешняя сортировка больших объёмов (работа с файлами).
• Стабильная многоключевая сортировка (например, сначала по дате, потом по имени).
• Параллельная сортировка с помощью std::execution::par.
Почему: гарантированное O(n log n), стабильность и лёгкое разделение на блоки.

---------------------------------------
Heap Sort (пирамидальная сортировка)
---------------------------------------
Задачи:
• Приоритетные очереди и планировщики задач.
• Сценарии с жёсткими ресурсными ограничениями (минимум доп. памяти).
• Когда нужен жёсткий «худший случай» O(n log n) без сюрпризов.
Почему: превращает диапазон в кучу за O(n), далее извлекает элементы за O(log n).

---------------------------------------
Insertion Sort (сортировка вставками)
---------------------------------------
Задачи:
• Маленькие или уже почти отсортированные массивы (кеш-оптимизация).
• Интервальные этапы в гибридных алгоритмах (например, внутри Introsort).
• Реaltime-системы с жёстким ограничением на время одной итерации.
Почему: простейшая, O(n²) на больших n, но при n<30 или близком к отсортированности – быстрее всех.

---------------------------------------
Counting / Radix Sort (подсчётная и поразрядная сортировка)
---------------------------------------
Задачи:
• Сортировка целых чисел или строк фиксированной длины (например, ID, ZIP-коды).
• Гистограммы, частотный анализ.
• Любые сценарии, где диапазон значений невелик по сравнению с объёмом данных.
Почему: линейное время O(n + k) при k – размер диапазона, плюс минимальные накладные расходы на сравнения.